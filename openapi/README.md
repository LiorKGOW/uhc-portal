This directory captures snapshots of OpenAPI definitions from backends.
Run `make openapi` (at the root level) to grab new ones and `yarn gen-types` to generate src/types/ TypeScript from them.

# WARNING: Manual patches

As of this writing we carry several manual patches to JSON and to types, that above commands overwrite:

- commit 56d37e7fa6cc571712ff1615880fce14dda1f170 added stuff into openapi/clusters_mgmt.v1.json
  (TODO: add in ocm-api-model)
- commit 52b7661c5249590f2e20fbd0910e78b08de5553d added manually written type files under
  src/types/clusters_mgmt.v1/models_/ + imports into generated clusters_mgmt.v1/index.ts
  (TODO: add in ocm-api-model)
- commit 423e07a328deed9d1c06b861628a097810f11434 edited the generated TypeScript, for 2 issues:
  - https://github.com/ferdikoomen/openapi-typescript-codegen/issues/1229
  - https://github.com/ferdikoomen/openapi-typescript-codegen/issues/1230
    (improved upstream, anyway we dropped that openapi in commit d8914c74abc6f374621951cabc876ba4edc07ac8)
- Added `"x-enum-varnames": [ "DISLIKE", "NO_VOTE", "LIKE" ]` to insights-results-aggregator JSONs
  (both v1 and v2) to avoid enum name collision: `enum user_vote { _1 = '-1', _0 = '0', _1 = '1', }`.
  https://github.com/ferdikoomen/openapi-typescript-codegen/issues/991

# Lifecycle of OpenAPI definitions

OCM uses APIs from 2 places:

- Docs UI: https://api.stage.openshift.com/ (or production https://api.openshift.com/)  
  UI source: https://gitlab.cee.redhat.com/service/uhc-gateway/-/blob/master/portal/src/index.js  
  Data of covered APIs: https://api.stage.openshift.com/api (or production https://api.openshift.com/api).

- Docs UI: https://console.redhat.com/docs/api  
  UI source: https://github.com/RedHatInsights/api-frontend/  
  Data of covered APIs: https://console.redhat.com/api, https://console.redhat.com/config/main.yml

But the actual OpenAPI json files rendered by these UIs are not hosted in any centralized place;
they are served live each from its corresponding backend, and owned by the respective backend team e.g.
https://api.stage.openshift.com/api/clusters_mgmt/v1/openapi — served by clusters-service here:
https://gitlab.cee.redhat.com/service/uhc-clusters-service/-/blob/master/cmd/clusters-service/servecmd/apiserver/static.go

How the OpenAPI jsons get updated in backends varies...  Details (as of this writing) on main ones:

- clusters-service (serving `clusters_mgmt` API) frequently implements APIs before they are documented.
  Source of truth are Go types in https://gitlab.cee.redhat.com/service/uhc-clusters-service/-/blob/master/pkg/api/

  (clusters-service does consume ocm-sdk-go types, but not for its server code, only for client calls to account-manager)

  Then (if not forgotten) they:

  1. Document it in custom DSL in https://github.com/openshift-online/ocm-api-model repo.
  2. This DSL is processed by https://github.com/openshift-online/ocm-api-metamodel tool.
     `metamodel generate openapi` emits both .json files, and encodes them as Go `[]byte` const.
  3. The generated OpenAPI JSON (and Go SDK code) get committed & released in https://github.com/openshift-online/ocm-sdk-go repo.
     (https://github.com/openshift-online/ocm-sdk-go/blob/main/clustersmgmt/v1/openapi.go,
     generated by https://github.com/openshift-online/ocm-api-metamodel/blob/92c5d3aaa3e15b39884e1f8a2e1f829ae266c8ac/pkg/generators/golang/openapi_generator.go#L225-L228)
  4. clusters-service bumps ocm-sdk-go version, and only then new OpenAPI is live on
     https://api.stage.openshift.com/api/clusters_mgmt/v1/openapi

  We don't want to wait for steps 2–4!
  `make openapi` pulls ocm-api-model repo and runs `metamodel` to produce fresh JSON.

- account-manager (serving `accounts_mgmt` and `authorizations` APIs) treats OpenAPI as source of truth:
  https://gitlab.cee.redhat.com/service/uhc-account-manager/-/tree/master/openapi
  They generate some of the server Go code from the OpenAPI, so we can expect the JSON they serve in staging to always be complete (neat!):
  https://api.stage.openshift.com/api/accounts_mgmt/v1/openapi

  What's confusing is the above process _also_ happens:  
  When people want to consume account-manager APIs via the Go SDK, they get added to ocm-api-model, processed by ocm-api-metamodel tool, and released in ocm-sdk-go.

  => The resulting 2nd OpenAPI JSON is not served anywhere.
  It's out of date, lower quality (e.g. less details on HTTP response code) and confusingly the types have different names.
  
  (account-manager does consume ocm-sdk-go but not for its own APIs, only for client calls to clusters-service)
