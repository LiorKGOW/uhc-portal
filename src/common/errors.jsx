import React from 'react';
import get from 'lodash/get';
import { clustersConstants } from '../redux/constants';

const BANNED_USER_CODE = 'ACCT-MGMT-22';
const TERMS_REQUIRED_CODE = 'CLUSTERS-MGMT-451';

function overrideErrorMessage(payload, actionType = undefined) {
  if (!payload) {
    return '';
  }

  let message = '';

  // override error by its kind
  const errorKind = get(payload, 'details[0].kind', '') || get(payload, 'errorDetails[0].kind', '');
  switch (errorKind) {
    case 'ExcessResources': {
      let resource = 'cluster';
      if (actionType !== undefined && /CLUSTER_ADDON/.test(actionType)) {
        resource = 'cluster add-on';
      }
      const verb = resource === 'cluster'
      && actionType !== undefined
      && actionType.includes(clustersConstants.EDIT_CLUSTER) ? 'edit' : 'create';
      message = `You are not authorized to ${verb} the ${resource} because your request exceeds available quota.
              In order to fulfill this request, you will need quota/subscriptions for:`;
      break;
    }
    default:
  }

  // override error by its code
  const errorCode = get(payload, 'code', '');
  switch (errorCode) {
    case BANNED_USER_CODE: // ErrorBanned
      message = (
        <span>
          Your account has been placed on
          {' '}
          <a href="https://access.redhat.com/articles/1340183" target="_blank" rel="noreferrer noopener">Export Hold</a>
          {' '}
          based on export control screening.
          <br />
          The Export Compliance Team has been notified that your account is on hold,
          {' '}
          and must conduct additional due diligence to resolve the Export Hold.
          <br />
          Try again in 24-48 hours.
        </span>
      );
      break;
    default:
  }

  return message;
}

function getErrorMessage(action) {
  if (action.payload.response === undefined) {
    // Handle edge cases in which `payload` might be an Error type
    return String(action.payload);
  }

  const response = action.payload.response.data;

  // Determine if error needs to be overridden
  const message = overrideErrorMessage(response, action.type);
  if (message) {
    return message;
  }

  // CMS uses "kind" for the error object, but AMS uses 'type'
  if (response !== undefined && (response.kind === 'Error' || response.type === 'Error')) {
    return `${response.code}:\n${response.reason}`;
  }

  return JSON.stringify(response);
}

/**
 * hasOwnErrorPage returns true is the api error has its won error page,
 * and it can be presented by ApiError.
 * @param {*} response The error response.
 */
const hasOwnErrorPage = response => get(response, 'data.code') === TERMS_REQUIRED_CODE;

/**
 * getErrorState returns the standard error state for a rejected redux action.
 * @param {*} action An action result object generated by redux-promise-middleware
 */
const getErrorState = action => (
  hasOwnErrorPage(get(action.payload, 'response')) ? {
    // drop this error if already handled by its own error page.
    pending: false,
    error: false,
    errorCode: '',
    internalErrorCode: '',
    errorMessage: '',
    errorDetails: null,
  } : {
    pending: false,
    error: action.error,
    errorCode: get(action.payload, 'response.status'),
    internalErrorCode: get(action.payload, 'response.data.code'),
    errorMessage: getErrorMessage(action),
    errorDetails: get(action.payload, 'response.data.details'),
    operationID: get(action.payload, 'response.data.operation_id'),
  }
);

function formatErrorDetails(errorDetails) {
  const customErrors = [];

  if (!errorDetails || !errorDetails.length) {
    return customErrors;
  }

  errorDetails.forEach((details) => {
    switch (details.kind) {
      case 'ExcessResources': {
        // Resource map: singular and plural
        const resourceMap = {
          addon: ['addon', 'addons'],
          'cluster.aws': ['cluster', 'clusters'],
          'cluster.gcp': ['cluster', 'clusters'],
          'compute.node.aws': ['node', 'nodes'],
          'compute.node.gcp': ['node', 'nodes'],
          'pv.storage.aws': ['GiB of storage', 'GiB of storage'],
          'pv.storage.gcp': ['GiB of storage', 'GiB of storage'],
          'network.loadbalancer.aws': ['load balancers', 'load balancers'],
          'network-gcp.loadbalancer.gcp': ['load balancers', 'load balancers'],
        };

        const getName = (type, count) => {
          if (resourceMap[type]) {
            return (resourceMap[type][count === 1 ? 0 : 1]);
          }
          return type;
        };

        // Add extra error details
        if (details && details.items) {
          customErrors.push((
            <ul>
              { details.items.map((excessResource) => {
                if (excessResource.resource_type === 'addon') {
                  return (
                    <li>
                      {`${excessResource.resource_type}: ${excessResource.resource_name}`}
                    </li>
                  );
                }
                if (resourceMap[excessResource.resource_type]) {
                  return (
                    <li>
                      { `${excessResource.count} additional
                  ${getName(excessResource.resource_type, excessResource.count)} of type
                  ${excessResource.availability_zone_type} availability zone, instance size
                  ${excessResource.resource_name}.`}
                    </li>
                  );
                }
                return 'An error occurred';
              })}
            </ul>
          ));
        } else {
          customErrors.push('Unknown resource');
        }
        break;
      }
      case 'AddOnParameterOptionList':
      case 'AddOnRequirementData': {
        if (details && details.items) {
          customErrors.push((
            <pre>
              {JSON.stringify(details.items, undefined, 2)}
            </pre>
          ));
        }
        break;
      }
      default:
        break;
    }
  });

  return customErrors;
}

export {
  getErrorState,
  formatErrorDetails,
  hasOwnErrorPage,
  getErrorMessage,
  overrideErrorMessage,

  BANNED_USER_CODE,
  TERMS_REQUIRED_CODE,
};
