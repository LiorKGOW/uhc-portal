import React from 'react';
import { AxiosError, AxiosResponse } from 'axios';
import { clustersConstants } from '../redux/constants';
import { ExcessResource } from '../types/accounts_mgmt.v1';
import { ErrorDetail, ErrorState } from '../types/types';

const BANNED_USER_CODE = 'ACCT-MGMT-22';
const TERMS_REQUIRED_CODE = 'CLUSTERS-MGMT-451';

const overrideErrorMessage = (payload: any, actionType?: string) => {
  if (!payload) {
    return '';
  }

  let message: string | React.ReactElement = '';

  // override error by its kind
  const errorKind = payload?.details?.[0]?.kind || payload?.errorDetails?.[0]?.kind;
  switch (errorKind) {
    case 'ExcessResources': {
      let resource = 'cluster';
      if (actionType !== undefined && /CLUSTER_ADDON/.test(actionType)) {
        resource = 'cluster add-on';
      }
      const verb =
        resource === 'cluster' &&
        actionType !== undefined &&
        actionType.includes(clustersConstants.EDIT_CLUSTER)
          ? 'edit'
          : 'create';
      message = `You are not authorized to ${verb} the ${resource} because your request exceeds available quota.
              In order to fulfill this request, you will need quota/subscriptions for:`;
      break;
    }
    default:
  }

  // override error by its code
  const errorCode = payload?.code;
  switch (errorCode) {
    case BANNED_USER_CODE: // ErrorBanned
      message = (
        <span>
          Your account has been placed on{' '}
          <a
            href="https://access.redhat.com/articles/1340183"
            target="_blank"
            rel="noreferrer noopener"
          >
            Export Hold
          </a>{' '}
          based on export control screening.
          <br />
          The Export Compliance Team has been notified that your account is on hold, and must
          conduct additional due diligence to resolve the Export Hold.
          <br />
          Try again in 24-48 hours.
        </span>
      );
      break;
    default:
  }

  return message;
};

const getErrorMessage = (action: { type?: string; payload?: AxiosError<any> }) => {
  if (action.payload?.response === undefined) {
    // Handle edge cases in which `payload` might be an Error type
    return String(action.payload);
  }

  const response = action.payload.response.data;

  // Determine if error needs to be overridden
  const message = overrideErrorMessage(response, action.type);
  if (message) {
    return message;
  }

  // CMS uses "kind" for the error object, but AMS uses 'type'
  if (response !== undefined && (response.kind === 'Error' || response.type === 'Error')) {
    return `${response.code}:\n${response.reason}`;
  }

  return JSON.stringify(response);
};

/**
 * hasOwnErrorPage returns true is the api error has its won error page,
 * and it can be presented by ApiError.
 * @param {*} response The error response.
 */
const hasOwnErrorPage = (response: AxiosResponse | undefined) =>
  response?.data?.code === TERMS_REQUIRED_CODE;

/**
 * getErrorState returns the standard error state for a rejected redux action.
 * @param {*} action An action result object generated by redux-promise-middleware
 */
const getErrorState = (action: {
  type?: string;
  error?: boolean;
  payload?: AxiosError<any>;
}): ErrorState | { pending: false; fulfilled: false; error: false } =>
  hasOwnErrorPage(action.payload?.response)
    ? {
        // drop this error if already handled by its own error page.
        fulfilled: false,
        pending: false,
        error: false,
      }
    : {
        fulfilled: false,
        pending: false,
        error: true,
        errorCode: action.payload?.response?.status,
        internalErrorCode: action.payload?.response?.data?.code,
        errorMessage: getErrorMessage(action),
        errorDetails: action.payload?.response?.data?.details,
        operationID: action.payload?.response?.data?.operation_id,
      };

const isExcessResourcesErrorDetail = (
  e: ErrorDetail,
): e is {
  kind: 'ExcessResources';
  items?: ExcessResource[];
} => e.kind === 'ExcessResources';

const formatErrorDetails = (errorDetails?: ErrorDetail[]): React.ReactNode[] => {
  const customErrors: React.ReactNode[] = [];

  if (!errorDetails || !errorDetails.length) {
    return customErrors;
  }

  errorDetails.forEach((details) => {
    if (isExcessResourcesErrorDetail(details)) {
      // Resource map: singular and plural
      const resourceMap: { [key: string]: string[] } = {
        addon: ['addon', 'addons'],
        'cluster.aws': ['cluster', 'clusters'],
        'cluster.gcp': ['cluster', 'clusters'],
        'compute.node.aws': ['node', 'nodes'],
        'compute.node.gcp': ['node', 'nodes'],
        'pv.storage.aws': ['GiB of storage', 'GiB of storage'],
        'pv.storage.gcp': ['GiB of storage', 'GiB of storage'],
        'network.loadbalancer.aws': ['load balancers', 'load balancers'],
        'network-gcp.loadbalancer.gcp': ['load balancers', 'load balancers'],
      };

      const getName = (type: string, count: number | undefined) => {
        if (resourceMap[type]) {
          return resourceMap[type][count === 1 ? 0 : 1];
        }
        return type;
      };

      // Add extra error details
      if (details.items) {
        customErrors.push(
          <ul>
            {details.items.map((excessResource) => {
              if (excessResource.resource_type === 'addon') {
                return (
                  <li>{`${excessResource.resource_type}: ${excessResource.resource_name}`}</li>
                );
              }
              if (excessResource.resource_type && resourceMap[excessResource.resource_type]) {
                return (
                  <li>
                    {`${excessResource.count} additional
                  ${getName(excessResource.resource_type, excessResource.count)} of type
                  ${excessResource.availability_zone_type} availability zone, instance size
                  ${excessResource.resource_name}.`}
                  </li>
                );
              }
              return 'An error occurred';
            })}
          </ul>,
        );
      } else {
        customErrors.push('Unknown resource');
      }
    } else if (
      details?.items &&
      ['AddOnParameterOptionList', 'AddOnRequirementData'].includes(details.kind)
    ) {
      customErrors.push(<pre>{JSON.stringify(details.items, undefined, 2)}</pre>);
    }
  });

  return customErrors;
};

export {
  getErrorState,
  formatErrorDetails,
  hasOwnErrorPage,
  getErrorMessage,
  overrideErrorMessage,
  BANNED_USER_CODE,
  TERMS_REQUIRED_CODE,
};
